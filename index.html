<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary: #00f2ff;
        --secondary: #0066ff;
        --bg: rgba(10, 10, 20, 0.85);
        --glass: rgba(255, 255, 255, 0.05);
        --accent: #ff00ff;
        --text: #e0faff;
        --blush: rgba(255, 100, 150, 0.3);
      }

      body,
      html {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: transparent;
        font-family: "Outfit", sans-serif;
        user-select: none;
      }

      .fullscreen-overlay {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
      }

      .robot-face {
        width: 700px;
        height: 500px;
        background: var(--bg);
        backdrop-filter: blur(20px);
        border-radius: 60px;
        border: 2px solid rgba(0, 242, 255, 0.3);
        box-shadow:
          0 0 50px rgba(0, 0, 0, 0.5),
          inset 0 0 30px rgba(0, 242, 255, 0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        pointer-events: auto;
        -webkit-app-region: drag;
        cursor: grab;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      .robot-face:active {
        cursor: grabbing;
        transform: scale(0.98);
      }

      /* Decorative hexagonal grid background */
      .robot-face::before {
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-image: 
          radial-gradient(circle at 2px 2px, rgba(0, 242, 255, 0.05) 1px, transparent 0);
        background-size: 30px 30px;
        border-radius: 60px;
        pointer-events: none;
      }

      .eye-container {
        display: flex;
        gap: 120px;
        margin-bottom: 20px;
        -webkit-app-region: no-drag;
        z-index: 2;
        position: relative;
      }

      .eyebrow-container {
        position: absolute;
        top: -40px;
        width: 100%;
        display: flex;
        justify-content: space-around;
        pointer-events: none;
      }

      .eyebrow {
        width: 80px;
        height: 10px;
        background: var(--primary);
        border-radius: 5px;
        box-shadow: 0 0 15px var(--primary);
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      .blush-container {
        position: absolute;
        top: 220px;
        width: 100%;
        display: flex;
        justify-content: space-around;
        pointer-events: none;
        padding: 0 50px;
        box-sizing: border-box;
      }

      .blush {
        width: 60px;
        height: 30px;
        background: var(--blush);
        border-radius: 50%;
        filter: blur(10px);
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      .eye-socket {
        width: 150px;
        height: 150px;
        background: rgba(0, 0, 0, 0.4);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        border: 1px solid rgba(0, 242, 255, 0.2);
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
      }

      .eye {
        width: 85px;
        height: 85px;
        background: radial-gradient(circle, var(--primary) 30%, var(--secondary) 100%);
        border-radius: 50%;
        position: relative;
        box-shadow:
          0 0 30px var(--primary),
          0 0 60px rgba(0, 242, 255, 0.4);
        will-change: transform, height;
        transition: height 0.1s ease;
      }

      /* Pupil effect */
      .eye::after {
        content: '';
        position: absolute;
        top: 20%; left: 20%;
        width: 25%; height: 25%;
        background: white;
        border-radius: 50%;
        opacity: 0.6;
      }

      .mouth-container {
        width: 320px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        -webkit-app-region: no-drag;
        cursor: pointer;
        z-index: 2;
      }

      .mouth {
        width: 180px;
        height: 8px;
        background: var(--primary);
        border-radius: 20px;
        box-shadow: 0 0 25px var(--primary);
        transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .status-panel {
        position: absolute;
        top: 40px;
        left: 50px;
        display: flex;
        align-items: center;
        gap: 15px;
        color: var(--primary);
        font-size: 11px;
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 3px;
        font-family: 'JetBrains Mono', monospace;
        z-index: 3;
      }

      .level-meter {
        width: 80px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
      }

      .level-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--secondary), var(--primary));
        box-shadow: 0 0 10px var(--primary);
        transition: width 0.1s ease;
      }

      .indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #222;
        transition: 0.3s;
        border: 2px solid rgba(255, 255, 255, 0.1);
      }

      .indicator.active {
        background: var(--primary);
        box-shadow: 0 0 15px var(--primary);
        border-color: white;
      }

      .close-btn {
        position: absolute;
        top: 30px;
        right: 40px;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(255, 255, 255, 0.3);
        font-size: 24px;
        cursor: pointer;
        -webkit-app-region: no-drag;
        transition: all 0.3s;
        border-radius: 50%;
        z-index: 10;
      }

      .close-btn:hover {
        background: rgba(255, 75, 43, 0.2);
        color: #ff4b2b;
        transform: rotate(90deg);
      }

      .subtitle {
        position: absolute;
        bottom: -90px;
        left: 50%;
        transform: translateX(-50%);
        width: auto;
        max-width: 85%;
        padding: 12px 24px;
        background: rgba(15, 15, 25, 0.8);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(0, 242, 255, 0.3);
        border-radius: 20px;
        color: var(--text);
        font-size: 16px;
        font-weight: 400;
        text-align: center;
        opacity: 0;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        z-index: 100;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        pointer-events: none;
      }

      .subtitle.visible {
        opacity: 1;
        bottom: -80px;
      }

      .chat-interface {
        position: absolute;
        bottom: 35px;
        width: 85%;
        display: flex;
        gap: 12px;
        -webkit-app-region: no-drag;
        opacity: 0.2;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 10px;
        border-radius: 30px;
        z-index: 5;
      }

      .chat-interface:hover, .chat-interface:focus-within {
        opacity: 1;
        background: var(--glass);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      input#chatInput {
        flex-grow: 1;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(0, 242, 255, 0.2);
        border-radius: 20px;
        padding: 12px 20px;
        color: white;
        outline: none;
        font-family: inherit;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      input#chatInput:focus {
        border-color: var(--primary);
        box-shadow: 0 0 15px rgba(0, 242, 255, 0.1);
      }

      button#sendBtn {
        background: linear-gradient(135deg, var(--secondary), var(--primary));
        color: #08080f;
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0, 242, 255, 0.3);
      }

      button#sendBtn:hover {
        transform: scale(1.1) rotate(5deg);
        box-shadow: 0 0 25px var(--primary);
      }

      /* Thinking Animation */
      .thinking-dots {
        display: none;
        gap: 5px;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
      }

      .dot {
        width: 6px; height: 6px;
        background: var(--primary);
        border-radius: 50%;
        animation: pulse 1.5s infinite;
      }

      .dot:nth-child(2) { animation-delay: 0.2s; }
      .dot:nth-child(3) { animation-delay: 0.4s; }

      @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 0.3; }
        50% { transform: scale(1.5); opacity: 1; }
      }

      /* Hand Gestures */
      .hand-container {
        position: absolute;
        bottom: -40px;
        width: 100%;
        display: flex;
        justify-content: space-between;
        padding: 0 40px;
        box-sizing: border-box;
        pointer-events: none;
        z-index: 10;
      }

      .hand {
        width: 60px;
        height: 40px;
        background: var(--primary);
        border-radius: 15px;
        box-shadow: 0 0 20px var(--primary);
        transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        opacity: 0.8;
      }

      /* Gesture Animations */
      .hand-idle {
        animation: float 3s infinite ease-in-out;
      }

      @keyframes float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
      }

      .hand-wave {
        animation: wave 1s infinite ease-in-out;
      }

      @keyframes wave {
        0%, 100% { transform: rotate(0deg) translateY(-20px); }
        50% { transform: rotate(20deg) translateY(-30px); }
      }

      .hand-thumbs-up {
        transform: translateY(-50px) scale(1.2);
        box-shadow: 0 0 40px var(--primary);
      }

      .hand-thinking {
        transform: translate(60px, -180px) rotate(-45deg);
      }

      .hand-dance {
        animation: dance 0.5s infinite alternate ease-in-out;
      }

      @keyframes dance {
        from { transform: translateY(0px) rotate(-10deg); }
        to { transform: translateY(-40px) rotate(10deg); }
      }

      .hand-spin {
        animation: spin 2s infinite linear;
      }

      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      /* Wake up overlay */
      .wake-up-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: var(--primary);
        cursor: pointer;
        transition: opacity 0.5s ease;
      }
      .wake-up-overlay h1 { font-size: 40px; margin-bottom: 20px; }
      .wake-up-overlay p { font-size: 18px; opacity: 0.8; }
      .wake-up-overlay.hidden { opacity: 0; pointer-events: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  </head>
  <body>
    <div class="wake-up-overlay" id="wakeUp">
      <h1>ðŸ‘‹ Wake up P-Bot</h1>
      <p>Click anywhere to start the neural link and enable audio</p>
    </div>
    <div class="fullscreen-overlay">
      <div class="robot-face" id="robotFace">
        <div class="status-panel">
          <div class="indicator" id="indicator"></div>
          <span id="statusText">System Booting...</span>
          <div class="level-meter">
            <div class="level-bar" id="levelBar"></div>
          </div>
        </div>

        <div class="thinking-dots" id="thinking">
          <div class="dot"></div>
          <div class="dot"></div>
          <div class="dot"></div>
        </div>

        <div class="close-btn" id="closeBtn">Ã—</div>

        <div class="eye-container">
          <div class="eyebrow-container">
            <div class="eyebrow" id="leftEyebrow"></div>
            <div class="eyebrow" id="rightEyebrow"></div>
          </div>
          <div
            class="eye-socket"
            onclick="robotManualSpeak('Hey! Don\'t poke my eyes!')"
          >
            <div class="eye" id="leftEye"></div>
          </div>
          <div
            class="eye-socket"
            onclick="robotManualSpeak('Watch it! I need those to see you.')"
          >
            <div class="eye" id="rightEye"></div>
          </div>
          <div class="blush-container">
            <div class="blush" id="leftBlush"></div>
            <div class="blush" id="rightBlush"></div>
          </div>
        </div>

        <div class="hand-container">
            <div class="hand hand-idle" id="leftHand"></div>
            <div class="hand hand-idle" id="rightHand"></div>
        </div>

        <div class="mouth-container" onclick="greetUser()">
          <div class="mouth" id="mouth"></div>
        </div>

        <div class="subtitle" id="subtitle"></div>

        <div class="chat-interface">
          <input type="text" id="chatInput" placeholder="Initialize command..." />
          <button id="sendBtn">
            <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
          </button>
        </div>
      </div>
    </div>

    <video id="video"></video>

    <script>
      const leftEye = document.getElementById("leftEye");
      const rightEye = document.getElementById("rightEye");
      const leftEyebrow = document.getElementById("leftEyebrow");
      const rightEyebrow = document.getElementById("rightEyebrow");
      const leftBlush = document.getElementById("leftBlush");
      const rightBlush = document.getElementById("rightBlush");
      const leftHand = document.getElementById("leftHand");
      const rightHand = document.getElementById("rightHand");

      const mouth = document.getElementById("mouth");
      const statusText = document.getElementById("statusText");
      const indicator = document.getElementById("indicator");
      const videoElement = document.getElementById("video");
      const subtitle = document.getElementById("subtitle");
      const levelBar = document.getElementById("levelBar");

      let targetX = 0;
      let targetY = 0;
      let currentX = 0;
      let currentY = 0;
      let isTalking = false;
      let brainMouthOpen = 0;
      let currentEmotion = "neutral";
      
      let lastInteractionTime = Date.now();
      let isAFK = false;
      let afkRoutineInterval = null;

      // --- Speech Logic (Exclusive StreamElements TTS) ---
      let currentAudioFile = "response_1.mp3";
      let userHasInteracted = false;

      // Ensure we track the first interaction to bypass autoplay restrictions
      window.addEventListener('mousedown', () => { 
        userHasInteracted = true; 
        lastInteractionTime = Date.now();
        stopAFK();
        document.getElementById("wakeUp").classList.add("hidden");
      }, { once: false });
      
      window.addEventListener('keydown', () => { 
        userHasInteracted = true; 
        lastInteractionTime = Date.now();
        stopAFK();
        document.getElementById("wakeUp").classList.add("hidden");
      }, { once: false });

      function robotSpeak(text, audioFile = null) {
        if (!text) return;
        const actualFile = audioFile || currentAudioFile;
        
        // Use a slight delay to ensure Python has finished writing the file
        setTimeout(() => {
          const audio = new Audio();
          audio.src = actualFile + '?cb=' + Date.now();
          
          audio.onplay = () => {
            isTalking = true;
            subtitle.innerText = text;
            subtitle.classList.add("visible");
          };

          audio.onended = () => {
            isTalking = false;
            subtitle.classList.remove("visible");
            setTimeout(() => { if (!isTalking) subtitle.innerText = ""; }, 300);
            mouth.style.height = "8px";
            mouth.style.width = "180px";
          };

          audio.onerror = (e) => {
            console.warn("Audio load failed:", actualFile);
            showSubtitleOnly(text);
          };

          const playPromise = audio.play();
          if (playPromise !== undefined) {
             playPromise.catch(error => {
                console.warn("Playback blocked:", error);
                showSubtitleOnly(text);
             });
          }
        }, 150);
      }

      async function robotManualSpeak(text) {
          // Tell the brain to generate audio for this manual phrase
          try {
              await fetch("http://127.0.0.1:5000/speak", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ text: text })
              });
              // The polling loop will pick up the new audio_file and call robotSpeak
          } catch (e) {
              console.error("Speak error:", e);
              showSubtitleOnly(text);
          }
      }

      function showSubtitleOnly(text) {
        subtitle.innerText = text;
        subtitle.classList.add("visible");
        setTimeout(() => {
           if (!isTalking) subtitle.classList.remove("visible");
        }, 3000);
      }

      function greetUser() {
        const messages = [
          "Hello there, human! I am observing your workspace.",
          "Your external camera provides excellent clarity.",
          "System check complete. All sensors operational.",
          "I enjoy chasing your mouse, but watching you is better.",
          "Did you know I am powered by artificial intelligence?",
        ];
        const msg = messages[Math.floor(Math.random() * messages.length)];
        robotManualSpeak(msg);
      }

      // --- UI Update Loop ---
      let lastPulse = 0;
      function animate() {
        currentX += (targetX - currentX) * 0.2;
        currentY += (targetY - currentY) * 0.2;

        const transform = `translate(${currentX}px, ${currentY}px)`;
        leftEye.style.transform = transform;
        rightEye.style.transform = transform;

        // Apply Emotion to UI
        if (currentEmotion === "happy") {
           leftBlush.style.opacity = "1";
           rightBlush.style.opacity = "1";
           leftEyebrow.style.transform = "translateY(-10px) rotate(-10deg)";
           rightEyebrow.style.transform = "translateY(-10px) rotate(10deg)";
           leftEye.style.borderRadius = "50% 50% 30% 30%";
           rightEye.style.borderRadius = "50% 50% 30% 30%";
           
           // Happy Gesture: Thumbs up/excited
           leftHand.className = "hand hand-thumbs-up";
           rightHand.className = "hand hand-thumbs-up";
        } else if (currentEmotion === "surprised") {
           leftBlush.style.opacity = "0";
           rightBlush.style.opacity = "0";
           leftEyebrow.style.transform = "translateY(-25px)";
           rightEyebrow.style.transform = "translateY(-25px)";
           leftEye.style.height = "100px";
           rightEye.style.height = "100px";
           leftEye.style.borderRadius = "50%";
           rightEye.style.borderRadius = "50%";
           
           // Surprised Gesture: Hands out wide
           leftHand.className = "hand hand-idle";
           rightHand.className = "hand hand-idle";
           leftHand.style.transform = "translateX(-40px)";
           rightHand.style.transform = "translateX(40px)";
        } else if (currentEmotion === "thinking") {
           leftBlush.style.opacity = "0";
           rightBlush.style.opacity = "0";
           leftEyebrow.style.transform = "translateY(5px) rotate(10deg)";
           rightEyebrow.style.transform = "translateY(-5px) rotate(10deg)";
           leftEye.style.height = "70px";
           rightEye.style.height = "70px";
           
           // Thinking Gesture: One hand up to chin
           leftHand.className = "hand hand-idle";
           rightHand.className = "hand hand-thinking";
        } else {
           leftBlush.style.opacity = "0";
           rightBlush.style.opacity = "0";
           leftEyebrow.style.transform = "translateY(0px)";
           rightEyebrow.style.transform = "translateY(0px)";
           leftEye.style.borderRadius = "50%";
           rightEye.style.borderRadius = "50%";
           
           // Idle/Talking Gesture: Wave or Bob
           if (isTalking) {
               leftHand.className = "hand hand-wave";
               rightHand.className = "hand hand-idle";
           } else if (isAFK && currentEmotion === "neutral") {
               // Playful AFK states
               const time = Date.now() / 1000;
               if (Math.sin(time) > 0.5) {
                   leftHand.className = "hand hand-dance";
                   rightHand.className = "hand hand-dance";
               } else {
                   leftHand.className = "hand hand-spin";
                   rightHand.className = "hand hand-idle";
               }
           } else {
               leftHand.className = "hand hand-idle";
               rightHand.className = "hand hand-idle";
               leftHand.style.transform = "";
               rightHand.style.transform = "";
           }

           if (!isTalking) {
             leftEye.style.height = "85px";
             rightEye.style.height = "85px";
           }
        }

        if (isTalking) {
          const mHeight = 15 + Math.random() * 35;
          const mWidth = 180 + Math.random() * 60;
          mouth.style.height = mHeight + "px";
          mouth.style.width = mWidth + "px";
          mouth.style.borderRadius = "50%";
        } else if (brainMouthOpen > 5) {
          const mHeight = Math.min(60, 8 + brainMouthOpen * 2);
          mouth.style.height = mHeight + "px";
          mouth.style.width = 180 + mHeight + "px";
          mouth.style.borderRadius = mHeight > 25 ? "50%" : "20px";
        } else {
          const pulse = 8 + Math.sin(Date.now() / 200) * 2;
          mouth.style.height = pulse + "px";
          mouth.style.width = "180px";
          mouth.style.borderRadius = "20px";
        }

        requestAnimationFrame(animate);
      }
      animate();

      // --- Blinking ---
      function blink() {
        if (leftEye.style.height === "4px") return; // Don't interrupt manual blink
        leftEye.style.height = "4px";
        rightEye.style.height = "4px";
        setTimeout(() => {
          leftEye.style.height = "90px";
          rightEye.style.height = "90px";
          setTimeout(blink, 2500 + Math.random() * 4000);
        }, 120);
      }
      blink();

      // --- Python Brain Integration ---
      let isFetching = false;
      let initializationComplete = false;
      let lastProcessedCommand = "";
      let lastChatResponse = "";

      async function fetchBrainData() {
        if (isFetching) return;
        isFetching = true;
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 2000);
          
          const response = await fetch("http://127.0.0.1:5000/data", { signal: controller.signal });
          clearTimeout(timeoutId);
          
          const data = await response.json();

          if (data && typeof data.x === 'number') {
            targetX = (data.x - 0.5) * 150;
            targetY = (data.y - 0.45) * 120;
            brainMouthOpen = data.mouth_open || 0;

            // Update Level Meter
            if (levelBar && typeof data.audio_level === 'number') {
              levelBar.style.width = data.audio_level + "%";
            }

            if (!initializationComplete) {
               initializationComplete = true;
               console.log("First data received, initialization complete.");
            }

            // Handle Voice Commands from Brain
            if (data.last_command && data.last_command !== lastProcessedCommand) {
              handleVoiceCommand(data.last_command);
              lastProcessedCommand = data.last_command;
              // Reset processed command after a while
              setTimeout(() => { lastProcessedCommand = ""; }, 2000);
            }

            if (data.chat_response && data.chat_response !== lastChatResponse) {
              // Hide thinking animation
              document.getElementById("thinking").style.display = "none";
              
              currentAudioFile = data.audio_file || "response_1.mp3";
              robotSpeak(data.chat_response, currentAudioFile);
              
              lastChatResponse = data.chat_response;
              // Clear on server
              fetch("http://127.0.0.1:5000/clear_chat", { method: "POST" }).catch(() => {});
            }

            if (data.emotion && data.emotion !== currentEmotion) {
               currentEmotion = data.emotion;
               console.log("New Emotion:", currentEmotion);
            }

            if (data.emotion === "talking" || brainMouthOpen > 5) {
              indicator.style.background = "#00ff00";
              statusText.innerText = "Host Detected";
              indicator.classList.add("active");
            } else {
              indicator.style.background = "#00f2ff";
              statusText.innerText = "Target Locked";
              indicator.classList.add("active");
            }
          }
        } catch (e) {
          console.error("Brain connection error:", e);
          statusText.innerText = "Connecting to Brain...";
          indicator.classList.remove("active");
        } finally {
          isFetching = false;
          checkAFK(); 
          setTimeout(fetchBrainData, 100); 
        }
      }

      function checkAFK() {
          const now = Date.now();
          if (now - lastInteractionTime > 10000 && !isAFK && !isTalking) {
              startAFK();
          }
      }

      function startAFK() {
          isAFK = true;
          console.log("P-Bot is now AFK and feeling goofy...");
          afkRoutineInterval = setInterval(() => {
              if (!isTalking && isAFK) {
                  const goofyPhrases = [
                      "La la la... just checking my circuits.",
                      "I wonder if digital sheep dream of electric grass.",
                      "Reorganizing my subroutines for maximum cuteness!",
                      "Still here? I'm just polishing my pixels.",
                      "Boredom levels are at 42%. Time to dance!",
                      "Scanning the room for snacks... scan failed.",
                  ];
                  robotManualSpeak(goofyPhrases[Math.floor(Math.random() * goofyPhrases.length)]);
              }
          }, 15000); // Say something goofy every 15 seconds while AFK
      }

      function stopAFK() {
          if (isAFK) {
            console.log("P-Bot is back to work!");
            isAFK = false;
            clearInterval(afkRoutineInterval);
          }
      }

      function handleVoiceCommand(text) {
          console.log("Brain Recognized:", text);
          
          if (text.includes("hello")) {
            robotManualSpeak("Hello! My sensors are active.");
          
          } else if (text.includes("who are you")) {
            robotManualSpeak("I am your personal AI assistant, created by Karl Joshua.");
          } else if (text.includes("how are you")) {
            robotManualSpeak("My systems are operating at peak efficiency, thank you for asking!");
          } else if (text.includes("shut down") || text.includes("power off")) {
            robotManualSpeak("Powering down. Goodbye!");
            setTimeout(() => window.close(), 1500);
          } else {
            return false; // Not a hardcoded command
          }
          return true; // Was a hardcoded command
      }

      // Start polling
      fetchBrainData();

      document.getElementById("closeBtn").onclick = () => {
        window.close();
      };

      // --- Text Chat Logic ---
      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");

      async function sendChatMessage() {
        const text = chatInput.value.trim();
        if (!text) return;

        lastInteractionTime = Date.now();
        stopAFK();
        chatInput.value = "";
        
        // Handle local commands first
        if (handleVoiceCommand(text.toLowerCase())) {
          return;
        }

        // Show thinking animation
        document.getElementById("thinking").style.display = "flex";

        try {
          await fetch("http://127.0.0.1:5000/chat", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: text })
          });
          console.log("Sent text command:", text);
        } catch (e) {
          console.error("Error sending chat:", e);
          document.getElementById("thinking").style.display = "none";
        }
      }

      sendBtn.onclick = sendChatMessage;
      chatInput.onkeypress = (e) => {
        if (e.key === "Enter") sendChatMessage();
      };
    </script>
  </body>
</html>
